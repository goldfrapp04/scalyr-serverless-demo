import boto3
import os
import json
import traceback

from urllib.parse import urlparse


_sns = boto3.client('sns')


class Constants:
    """Holds constants definitions for Lambdas.  This mostly contains string
    constants for JSON keys.
    """

    # The following are JSON keys for ImagePayload
    IMAGE_URL = 'ImageURL'
    POST_ID = 'PostID'
    ACCOUNT_ID = 'AccountID'
    SOURCE_DEVICE = 'SourceDevice'
    CREATED_TIMESTAMP = 'CreatedTimestamp'
    ROOT_TRACE_ID = 'RootTraceID'
    # The following are JSON keys for UpdateSpamScorePayload
    IMAGE_PAYLOAD = 'ImagePayload'
    SCORER = 'Scorer'
    SCORE = 'Score'
    SCORER_TRACE_ID = 'ScorerTraceID'


class HandlerError(Exception):
    """Base class for all exceptions generated by the Lambda handlers.

    Subclasses may define the HTTP status code that should be returned
    when their exception is raised.
    """

    def __init__(self, status_code: int, message: str):
        """Constructs new instance.

        :param status_code: The HTTP status code that should be returned
            by the handler due to this exception.
        :param message: The message to include in HTTP response by the
            handler due to this exception.
        """
        super().__init__(message)
        self.__status_code = status_code
        self.__message = message

    @property
    def status_code(self) -> int:
        """
        :return: The HTTP status code to return due to this exception.
        """
        return self.__status_code

    def create_response(self) -> dict:
        """
        :return: The HTTP response to return by the Lambda due to this
            exception.
        """
        return {
            'statusCode': self.__status_code,
            'headers': {'Content-Type': 'text/plain'},
            'body': self.__message,
        }


class MissingRequiredField(HandlerError):
    """Raised when a JSON object is passed to the Lambda handler that is
    missing a required field.
    """

    def __init__(self, message):
        super().__init__(500, message)


class InvalidJSON(HandlerError):
    """Raised when a JSON object passed to the Lambda handler is invalid.
    """

    def __init__(self, message):
        super().__init__(400, message)


class MissingSnsTopicEnvironmentVariableException(HandlerError):
    """Raised when a Lambda is missing an environment variable holding a
    SNS topic ARN.
    """

    def __init__(self, topic_environment_variable_name):
        super().__init__(
            500,
            f"Missing environment variable {topic_environment_variable_name} "
            f"which is required to publish to SNS topic.  Maybe it was not "
            f"properly added to the Lambda\'s environment.",
        )


class SnsPublishError(HandlerError):
    """Raised when an error occurs when publishing to an SNS Topic.
    """

    def __init__(self, sns_response):
        super().__init__(
            500,
            f"Failed during SNS publishing.  Response was {json.dumps(sns_response)}",
        )


class SnsReceiveError(HandlerError):
    """Raised when processing an event from an SNS Topic.
    """

    def __init__(self, message):
        super().__init__(500, message)


def parse_json(payload: str, required_fields=None) -> dict:
    """Parses the payload as JSON.  This will raise a `InvalidJSON` exception
    if it is not valid JSON.

    Optionally will verify the JSON has a set of required fields as top-level
    members.  If any are missing, then a `MissingRequiredField` exception
    is raised.
    :param payload: The string to parse as JSON.
    :param required_fields: The set of field names to ensure are present in
        the parsed object.  If any are missing, a `MissingRequiredField`
        exception is thrown.
    :return: The parsed JSON as a dict.
    """
    try:
        parsed = json.loads(payload)
    except json.decoder.JSONDecodeError as e:
        raise InvalidJSON(e.msg)

    if required_fields is not None:
        for x in required_fields:
            if x not in parsed:
                raise MissingRequiredField(f'Missing required field {x}')
    return parsed


def return_message(http_status_code: int, message: str) -> dict:
    """A dict that can be returned as the result of a Lambda invocation.

    :param http_status_code: The HTTP status code to return.
    :param message: The message body to return.
    :return: The dict representing the response
    """
    return {
        'statusCode': http_status_code,
        'headers': {'Content-Type': 'text/plain'},
        'body': message,
    }


class ImagePayload:
    """Holds data about an Image Payload, and can serialize the data with .to_json()

    :param image_url: A S3 URL to an image in a publicly accessible bucket
    :param post_id: A unique ID for the post
    :param account_id: A unique ID for the account creating the post
    :param source_device: The device type like ios, android, web, etc
    :param created_timestamp: A unix timestamp when the post was created
    :param root_trace_id: The trace_id received from API Gateway

    :return: A JSON payload for processing by the Lambdas
    """

    def __init__(
        self,
        image_url: str,
        post_id: str,
        account_id: str,
        source_device: str,
        created_timestamp: float,
        root_trace_id: str,
    ):

        self.image_url = image_url
        self.post_id = post_id
        self.account_id = account_id
        self.source_device = source_device
        self.created_timestamp = created_timestamp
        self.root_trace_id = root_trace_id

    def to_dict(self) -> dict:
        """
        :return: The object as dict
        :rtype:
        """
        return {
            Constants.IMAGE_URL: self.image_url,
            Constants.POST_ID: self.post_id,
            Constants.ACCOUNT_ID: self.account_id,
            Constants.SOURCE_DEVICE: self.source_device,
            Constants.CREATED_TIMESTAMP: self.created_timestamp,
            Constants.ROOT_TRACE_ID: self.root_trace_id,
        }

    def to_json(self) -> str:
        """
        :return: The JSON serialization of the object.
        """
        return json.dumps(self.to_dict())

    @staticmethod
    def from_json(payload: str):
        """Parsed the JSON contained in `payload` and returns the result as
        a ImagePayload.

        `InvalidJSON` and `MissingRequiredFields` may be thrown if any
        errors are seen during processing.

        :param payload: The string containing the JSON.
        :return: The parsed ImagePayload
        :rtype: ImagePayload
        """
        parsed_payload = parse_json(
            payload,
            required_fields={
                Constants.IMAGE_URL,
                Constants.POST_ID,
                Constants.ACCOUNT_ID,
                Constants.SOURCE_DEVICE,
                Constants.CREATED_TIMESTAMP,
                Constants.ROOT_TRACE_ID,
            },
        )
        return ImagePayload(
            parsed_payload[Constants.IMAGE_URL],
            parsed_payload[Constants.POST_ID],
            parsed_payload[Constants.ACCOUNT_ID],
            parsed_payload[Constants.SOURCE_DEVICE],
            parsed_payload[Constants.CREATED_TIMESTAMP],
            parsed_payload[Constants.ROOT_TRACE_ID],
        )


class UpdateSpamScorePayload:
    """Represents a spams core update that should be applied by the
    UpdateSpamScore Lambda.
    """

    def __init__(
        self, image_payload: ImagePayload, scorer: str, score: float, scorer_trace_id
    ):
        """Constructs an instance.

        :param image_payload: The image payload that was scored.
        :param scorer: The name of the scorer, such as `detect_spammy_words`.
        :param score: The score from 0 to 1.
        :param scorer_trace_id: The trace id of the scoring Lambda.
        """
        self.image_payload = image_payload
        self.scorer = scorer
        self.score = score
        self.scorer_trace_id = scorer_trace_id

    def to_json(self) -> str:
        """
        :return: The JSON representation of the object.
        """
        payload = {
            Constants.IMAGE_PAYLOAD: self.image_payload.to_dict(),
            Constants.SCORER: self.scorer,
            Constants.SCORE: self.score,
            Constants.SCORER_TRACE_ID: self.scorer_trace_id,
        }
        return json.dumps(payload)

    @staticmethod
    def from_json(payload: str):
        """Parsed the JSON contained in `payload` and returns the result as
        a UpdateSpamScorePayload.

        `InvalidJSON` and `MissingRequiredFields` may be thrown if any
        errors are seen during processing.

        :param payload: The string containing the JSON.
        :return: The parsed UpdateSpamScorePayload
        :rtype: UpdateSpamScorePayload
        """
        parsed_payload = parse_json(
            payload,
            required_fields={
                Constants.IMAGE_PAYLOAD,
                Constants.SCORER,
                Constants.SCORE,
                Constants.SCORER_TRACE_ID,
            },
        )

        # TODO: Fix inefficiency where we re-serialize the image payload.
        image_payload = ImagePayload.from_json(
            json.dumps(parsed_payload[Constants.IMAGE_PAYLOAD])
        )
        return UpdateSpamScorePayload(
            image_payload,
            parsed_payload[Constants.SCORER],
            parsed_payload[Constants.SCORE],
            parsed_payload[Constants.SCORER_TRACE_ID],
        )


def _publish_to_sns_topic(topic_arn_environment_var: str, payload) -> dict:
    """Publishes the payload object to the SNS topic contained in the
    specified environment variable.

    If any error is encountered during publish, `SnsPublishError` is raised.

    :param topic_arn_environment_var: The name of the environment variable
        containing the ARN of the SNS Topic.
    :param payload: The payload to publish.  This object must have a
        to_json method.
    :return: The SNS response if it is a success.
    """
    topic_arn = os.environ.get(topic_arn_environment_var, None)
    if topic_arn is None:
        raise MissingSnsTopicEnvironmentVariableException(topic_arn_environment_var)

    sns_response = _sns.publish(TopicArn=topic_arn, Message=payload.to_json())
    try:
        if sns_response['ResponseMetadata']['HTTPStatusCode'] == 200:
            return sns_response
    except KeyError:
        pass

    raise SnsPublishError(sns_response)


def publish_to_analyze_image_sns_topic(
    image_url: str,
    post_id: str,
    account_id: str,
    source_device: str,
    created_timestamp: float,
    root_trace_id: str,
) -> dict:
    """Publishes the specified image and its metadata to the `analyze_image`
    SNS Topic to be processed by the detection Lambdas.

    An appropriate HandlerException is raised if any errors are encountered
    or the SNS publish is not successful.

    :param image_url: The URL of the image.
    :param post_id: The id of the post sharing the image.
    :param account_id: The account id that authored the post.
    :param source_device: The type of device that published the image.
    :param created_timestamp:  The timestamp.
    :param root_trace_id: The id of the root trace that is initiating this
        processing.
    :return: The response from SNS if the publish is successful.
    """
    payload = ImagePayload(
        image_url, post_id, account_id, source_device, created_timestamp, root_trace_id
    )
    return _publish_to_sns_topic('SNS_ANALYZE_IMAGE_TOPIC_ARN', payload)


def publish_to_update_spam_score_sns_topic(
    image_payload: ImagePayload, scorer: str, score: float, scorer_trace_id
) -> dict:
    """Publishes the specified image and its metadata to the `update_spam_score`
    SNS Topic to be processed by UpdateSpamScore Lambda.

    An appropriate HandlerException is raised if any errors are encountered
    or the SNS publish is not successful.

    :param image_payload: The image payload that was scored
    :param scorer: The name of the scorer
    :param score: The score between 0 and 1.
    :param scorer_trace_id: The trace id that performed this scoring.
    :return: The response from SNS if the publish is successful.
    """
    payload = UpdateSpamScorePayload(image_payload, scorer, score, scorer_trace_id)
    return _publish_to_sns_topic('SNS_UPDATE_SPAM_SCORE_TOPIC_ARN', payload)


def _receive_from_sns_topic(event: dict) -> str:
    """Receives an event from an SNS topic and extracts the underlying message.

    An appropriate HandlerException is raised if there are any errors.

    :param event: The event that triggered the Lambda.
    :return: The underlying message.
    """
    try:
        return event['Records'][0]['Sns']['Message']
    except KeyError as e:
        raise SnsReceiveError(f"Missing field {e} when receiving sns event")


def receive_from_analyze_image_sns_topic(event: dict) -> ImagePayload:
    """Receives an event from the analyze_image SNS topic and extracts
    the underlying ImagePayload object.

    An appropriate HandlerException is raised if there are any errors.

    :param event: The event that triggered the Lambda.
    :return: The underlying ImagePayload.
    """
    return ImagePayload.from_json(_receive_from_sns_topic(event))


def receive_from_update_spam_score_sns_topic(event: dict) -> UpdateSpamScorePayload:
    """Receives an event from the update_spam_score SNS topic and extracts
    the underlying UpdateSpamScorePayload object.

    An appropriate HandlerException is raised if there are any errors.

    :param event: The event that triggered the Lambda.
    :return: The underlying UpdateSpamScorePayload.
    """
    return UpdateSpamScorePayload.from_json(_receive_from_sns_topic(event))


class DetectionHandler:
    """Base class for all handlers that calculate a spam score for an image.
    """

    def __init__(self, handler_name: str):
        """Creates an instance.

        :param handler_name: The name of the handler deriving this class.
        """
        self.__handler_name = handler_name

    def handle_request(self, event: dict, context) -> dict:
        """Handles a Lambda invocation.

        :param event: The event passed into the Lambda invocation.
        :param context: The context passed into the Lambda invocation.
        :return: The response to return for the Lambda invocation.
        """
        try:
            print(f"request: {json.dumps(event)}")
            print(f"context: {dump_context(context)}")

            image_payload = receive_from_analyze_image_sns_topic(event)

            root_trace_id = image_payload.root_trace_id
            print(f"RootTraceID: {root_trace_id}")

            score = self._score_image(image_payload)

            update_spam_score_result = publish_to_update_spam_score_sns_topic(
                image_payload, self.__handler_name, score, context.aws_request_id
            )

            print(f"update_spam_score_result: {update_spam_score_result}")

            return {
                'statusCode': 200,
                'headers': {'Content-Type': 'text/plain'},
                'body': 'Hello, you have reached {}.'.format(self.__handler_name),
            }
        except HandlerError as e:
            print(f"[ERROR] {e}: ")
            traceback.print_stack()
            return e.create_response()

    # noinspection PyMethodMayBeStatic
    def _score_image(self, _image_payload: ImagePayload) -> float:
        """Derived classes must override this to define how they will calculate
        spam scores.

        :param _image_payload: The image to score.
        :return: The spam score from 0 to 1.
        """
        return 0


class S3Url(object):
    """
    Helper class that takes a S3 URL in format
    and has methods to retrieve the Bucket name, Key name, and entire URL
    :param url: A S3 URL such as "S3://bucket/path/file.jpeg"
    :type url: str
    """

    def __init__(self, url):
        try:
            self._parsed = urlparse(url, allow_fragments=False)

            self._bucket = self._parsed.netloc
            self._key = self._parsed.path.lstrip('/')
            self._url = self._parsed.geturl()
        except ValueError:
            print("exception while attempting to urlparse: {}".format(url))
            raise

    @property
    def bucket(self) -> str:
        return self._bucket

    @property
    def key(self) -> str:
        return self._key

    @property
    def url(self) -> str:
        return self._url


def dump_context(context):
    return (
        "request_id={},log_group_name={},log_stream_name={},"
        "function_name={},limit={},version={},arn={}".format(
            context.aws_request_id,
            context.log_group_name,
            context.log_stream_name,
            context.function_name,
            context.memory_limit_in_mb,
            context.function_version,
            context.invoked_function_arn,
        )
    )
