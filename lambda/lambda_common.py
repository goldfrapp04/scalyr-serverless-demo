import time

import boto3
import os
import json
import traceback

from typing import Union
from urllib.parse import urlparse


_sns = boto3.client('sns')


def _get_pipeline_lambda_version() -> str:
    """Returns the current version number for the Pipeline Lambdas.

    This is determined by the contents of `lambda/VERSION`.  This is not the same as
    the Lambda version number in AWS.

    :return: The Pipeline Lambda software version number.
    """
    try:
        with open('VERSION') as file:
            return file.read().replace('\n', '').strip()
    except (IOError, OSError) as e:
        print(f"Could not read version due to: {e}")
        return "Unknown"


_PIPELINE_LAMBDA_VERSION = _get_pipeline_lambda_version()


class Constants:
    """Holds constants definitions for Lambdas.  This mostly contains string
    constants for JSON keys.
    """

    # The following are JSON keys for ImagePayload
    IMAGE_URL = 'ImageURL'
    POST_ID = 'PostID'
    ACCOUNT_ID = 'AccountID'
    SOURCE_DEVICE = 'SourceDevice'
    CREATED_TIMESTAMP = 'CreatedTimestamp'
    ROOT_TRACE_ID = 'RootTraceID'
    # The following are JSON keys for UpdateSpamScorePayload
    IMAGE_PAYLOAD = 'ImagePayload'
    SCORER = 'Scorer'
    SCORE = 'Score'
    SCORER_TRACE_ID = 'ScorerTraceID'


class HandlerError(Exception):
    """Base class for all exceptions generated by the Lambda handlers.

    Subclasses may define the HTTP status code that should be returned
    when their exception is raised.
    """

    def __init__(self, status_code: int, message: str, is_retriable: bool = True):
        """Constructs new instance.

        :param status_code: The HTTP status code that should be returned
            by the handler due to this exception.
        :param message: The message to include in HTTP response by the
            handler due to this exception.
        :param is_retriable: True if this error may be resolved if the
            handler is rerun.  If this is False then `create_response`
            will return a 200 if the handler is servicing SNS events.
            (Because retrying it will not help, so better to just
            mark event as done.)
        """
        super().__init__(message)
        self.__status_code = status_code
        self.__message = message
        self.__is_retriable = is_retriable

    @property
    def status_code(self) -> int:
        """
        :return: The HTTP status code to return due to this exception.
        """
        return self.__status_code

    def create_response(self, for_sns_topic: bool = False) -> dict:
        """
        :param for_sns_topic:  True if this response is for an event for an
            SNS topic.  If this is True and the error is not retriable, will
            just return a status code of 200 to dequeue the event.
        :return: The HTTP response to return by the Lambda due to this
            exception.
        """
        status_code = self.__status_code
        if not self.__is_retriable and for_sns_topic:
            status_code = 200
        return {
            'statusCode': status_code,
            'headers': {'Content-Type': 'text/plain'},
            'body': self.__message,
        }


class MissingRequiredField(HandlerError):
    """Raised when a JSON object is passed to the Lambda handler that is
    missing a required field.
    """

    def __init__(self, message):
        super().__init__(500, message, is_retriable=False)


class InvalidJSON(HandlerError):
    """Raised when a JSON object passed to the Lambda handler is invalid.
    """

    def __init__(self, message):
        super().__init__(400, message, is_retriable=False)


class MissingSnsTopicEnvironmentVariableException(HandlerError):
    """Raised when a Lambda is missing an environment variable holding a
    SNS topic ARN.
    """

    def __init__(self, topic_environment_variable_name):
        super().__init__(
            500,
            f"Missing environment variable {topic_environment_variable_name} "
            f"which is required to publish to SNS topic.  Maybe it was not "
            f"properly added to the Lambda\'s environment.",
            is_retriable=False,
        )


class SnsPublishError(HandlerError):
    """Raised when an error occurs when publishing to an SNS Topic.
    """

    def __init__(self, sns_response):
        super().__init__(
            500,
            f"Failed during SNS publishing.  Response was {json.dumps(sns_response)}",
        )


class SnsReceiveError(HandlerError):
    """Raised when processing an event from an SNS Topic.
    """

    def __init__(self, message):
        super().__init__(500, message)


class InvalidHandlerInputError(HandlerError):
    """Raised when an invalid input is received as an argument to a Lambda
    """

    def __init__(self, message):
        super().__init__(500, message, is_retriable=False)


def calculate_latency_ms(start_time: Union[float, None]) -> int:
    """Determine the number of milliseconds that have elaspsed since the
    specified start time.

    Allows `start_time` to be None, though that is not expected to happen
    in regular processing.  Returns a -1 in that case.

    :param start_time: The start time in fractional seconds since epoch.
    :return: The number of elapsed milliseconds
    """
    if start_time is None:
        return -1
    return round((time.time() - start_time) * 1000)


# TODO: Maybe LogContext would be better implemented as part of Python's
# logger functionality.
class LogContext:
    """Used to emit logs from a single invocation of a Lambda.

    The context holds information about who invoked the Lambda by
    tracking the root trace id, parent trace id and current trace id.

    This abstraction provides methods for emitting common log messages
    for all Lambdas.
    """

    def __init__(
        self,
        lambda_name: str,
        function_version: int,
        root_trace: str = None,
        parent_trace: str = None,
        current_trace: str = None,
    ):
        """Creates an instance to be used for all logging by a single Lambda invocation.

        :param lambda_name: The name of the Lambda being invoked.
        :param function_version: The AWS function version number for the Lambda.
        :param root_trace: The id of the root trace that caused this Lambda to
            be invoked.
        :param parent_trace: The id of the trace that invoked this Lambda.
        :param current_trace: The id of the current trace used by this Lambda
            invocation.
        """
        self.__lambda_name = lambda_name
        self.__function_version = function_version
        self.__root_trace = root_trace
        self.__parent_trace = parent_trace
        self.__current_trace = current_trace
        self.__pipeline_version = _PIPELINE_LAMBDA_VERSION
        # Used to track when the Lambda began execution.  Set in `log_start_message`.
        self.__start_time: Union[float, None] = None

    def log_start_message(self):
        """Emits the common start message for all Lambda invocations.
        """
        self.__start_time = time.time()
        print(
            f"START Lambda execution: lambda={self.__lambda_name} "
            f"version={self.__pipeline_version} "
            f"aws_version={self.__function_version} "
            f"trace={self.__current_trace} "
            f"rtrace={self.__root_trace} "
            f"ptrace={self.__parent_trace}"
        )

    def log(self, message: str):
        """Can be used to emit a message while a Lambda is running.  This will
         include the current trace id and the version number (as defined in
         `VERSION`) of the Lambda code.

        :param message: The message to emit.
        """
        print(
            f"{message} trace={self.__current_trace} version={self.__pipeline_version}"
        )

    def log_end_message(self, status_code: int, message: str):
        """Emits the end of Lambda message, recording the overall latency of
        the execution as well as the resulting status code.

        :param status_code:
        :param message:
        """
        print(
            f"END Lambda execution: lambda={self.__lambda_name} "
            f"status_code={status_code} "
            f"latency_ms={calculate_latency_ms(self.__start_time)} "
            f"message=\"{message}\" "
            f"version={self.__pipeline_version} "
            f"trace={self.__current_trace} "
            f"rtrace={self.__root_trace} "
            f"ptrace={self.__parent_trace}"
        )


def parse_json(payload: str, required_fields=None) -> dict:
    """Parses the payload as JSON.  This will raise a `InvalidJSON` exception
    if it is not valid JSON.

    Optionally will verify the JSON has a set of required fields as top-level
    members.  If any are missing, then a `MissingRequiredField` exception
    is raised.
    :param payload: The string to parse as JSON.
    :param required_fields: The set of field names to ensure are present in
        the parsed object.  If any are missing, a `MissingRequiredField`
        exception is thrown.
    :return: The parsed JSON as a dict.
    """
    try:
        parsed = json.loads(payload)
    except json.decoder.JSONDecodeError as e:
        raise InvalidJSON(e.msg)

    if required_fields is not None:
        for x in required_fields:
            if x not in parsed:
                raise MissingRequiredField(f'Missing required field {x}')
    return parsed


def return_message(http_status_code: int, message: str) -> dict:
    """A dict that can be returned as the result of a Lambda invocation.

    :param http_status_code: The HTTP status code to return.
    :param message: The message body to return.
    :return: The dict representing the response
    """
    return {
        'statusCode': http_status_code,
        'headers': {'Content-Type': 'text/plain'},
        'body': message,
    }


class ImagePayload:
    """Holds data about an Image Payload, and can serialize the data with .to_json()

    :param image_url: A S3 URL to an image in a publicly accessible bucket
    :param post_id: A unique ID for the post
    :param account_id: A unique ID for the account creating the post
    :param source_device: The device type like ios, android, web, etc
    :param created_timestamp: A unix timestamp when the post was created
    :param root_trace_id: The trace_id received from API Gateway

    :return: A JSON payload for processing by the Lambdas
    """

    def __init__(
        self,
        image_url: str,
        post_id: str,
        account_id: str,
        source_device: str,
        created_timestamp: float,
        root_trace_id: str,
    ):

        self.image_url = image_url
        self.post_id = post_id
        self.account_id = account_id
        self.source_device = source_device
        self.created_timestamp = created_timestamp
        self.root_trace_id = root_trace_id

    def to_dict(self) -> dict:
        """
        :return: The object as dict
        :rtype:
        """
        return {
            Constants.IMAGE_URL: self.image_url,
            Constants.POST_ID: self.post_id,
            Constants.ACCOUNT_ID: self.account_id,
            Constants.SOURCE_DEVICE: self.source_device,
            Constants.CREATED_TIMESTAMP: self.created_timestamp,
            Constants.ROOT_TRACE_ID: self.root_trace_id,
        }

    def to_json(self) -> str:
        """
        :return: The JSON serialization of the object.
        """
        return json.dumps(self.to_dict())

    @staticmethod
    def from_json(payload: str):
        """Parsed the JSON contained in `payload` and returns the result as
        a ImagePayload.

        `InvalidJSON` and `MissingRequiredFields` may be thrown if any
        errors are seen during processing.

        :param payload: The string containing the JSON.
        :return: The parsed ImagePayload
        :rtype: ImagePayload
        """
        parsed_payload = parse_json(
            payload,
            required_fields={
                Constants.IMAGE_URL,
                Constants.POST_ID,
                Constants.ACCOUNT_ID,
                Constants.SOURCE_DEVICE,
                Constants.CREATED_TIMESTAMP,
                Constants.ROOT_TRACE_ID,
            },
        )
        return ImagePayload(
            parsed_payload[Constants.IMAGE_URL],
            parsed_payload[Constants.POST_ID],
            parsed_payload[Constants.ACCOUNT_ID],
            parsed_payload[Constants.SOURCE_DEVICE],
            parsed_payload[Constants.CREATED_TIMESTAMP],
            parsed_payload[Constants.ROOT_TRACE_ID],
        )


class UpdateSpamScorePayload:
    """Represents a spams core update that should be applied by the
    UpdateSpamScore Lambda.
    """

    def __init__(
        self, image_payload: ImagePayload, scorer: str, score: float, scorer_trace_id
    ):
        """Constructs an instance.

        :param image_payload: The image payload that was scored.
        :param scorer: The name of the scorer, such as `detect_spammy_words`.
        :param score: The score from 0 to 1.
        :param scorer_trace_id: The trace id of the scoring Lambda.
        """
        self.image_payload = image_payload
        self.scorer = scorer
        self.score = score
        self.scorer_trace_id = scorer_trace_id

    def to_json(self) -> str:
        """
        :return: The JSON representation of the object.
        """
        payload = {
            Constants.IMAGE_PAYLOAD: self.image_payload.to_dict(),
            Constants.SCORER: self.scorer,
            Constants.SCORE: self.score,
            Constants.SCORER_TRACE_ID: self.scorer_trace_id,
        }
        return json.dumps(payload)

    @staticmethod
    def from_json(payload: str):
        """Parsed the JSON contained in `payload` and returns the result as
        a UpdateSpamScorePayload.

        `InvalidJSON` and `MissingRequiredFields` may be thrown if any
        errors are seen during processing.

        :param payload: The string containing the JSON.
        :return: The parsed UpdateSpamScorePayload
        :rtype: UpdateSpamScorePayload
        """
        parsed_payload = parse_json(
            payload,
            required_fields={
                Constants.IMAGE_PAYLOAD,
                Constants.SCORER,
                Constants.SCORE,
                Constants.SCORER_TRACE_ID,
            },
        )

        # TODO: Fix inefficiency where we re-serialize the image payload.
        image_payload = ImagePayload.from_json(
            json.dumps(parsed_payload[Constants.IMAGE_PAYLOAD])
        )
        return UpdateSpamScorePayload(
            image_payload,
            parsed_payload[Constants.SCORER],
            parsed_payload[Constants.SCORE],
            parsed_payload[Constants.SCORER_TRACE_ID],
        )


def _publish_to_sns_topic(
    topic_name: str,
    topic_arn_environment_var: str,
    payload,
    log_context: LogContext = None,
) -> dict:
    """Publishes the payload object to the SNS topic contained in the
    specified environment variable.

    If any error is encountered during publish, `SnsPublishError` is raised.

    :param topic_name: The name of the SNS topic.
    :param topic_arn_environment_var: The name of the environment variable
        containing the ARN of the SNS Topic.
    :param payload: The payload to publish.  This object must have a
        to_json method.
    :param log_context: The log context to use to emit log messages.
    :return: The SNS response if it is a success.
    """
    topic_arn = os.environ.get(topic_arn_environment_var, None)
    if topic_arn is None:
        raise MissingSnsTopicEnvironmentVariableException(topic_arn_environment_var)

    if log_context is not None:
        log_context.log(f"START publish_to_sns_topic topic={topic_name}")

    start_time = time.time()
    sns_response = _sns.publish(TopicArn=topic_arn, Message=payload.to_json())
    latency_ms = calculate_latency_ms(start_time)
    try:
        if sns_response['ResponseMetadata']['HTTPStatusCode'] == 200:
            if log_context is not None:
                log_context.log(
                    f"END publish_to_sns_topic topic={topic_name} "
                    f"latency_ms={latency_ms} result=200"
                )
            return sns_response
    except KeyError:
        pass

    if log_context is not None:
        log_context.log(
            f"END publish_to_sns_topic topic={topic_name} "
            f"latency_ms={latency_ms} result=500 "
            f"response={json.dumps(sns_response)}"
        )

    raise SnsPublishError(sns_response)


def publish_to_analyze_image_sns_topic(
    image_url: str,
    post_id: str,
    account_id: str,
    source_device: str,
    created_timestamp: float,
    root_trace_id: str,
    log_context: LogContext = None,
) -> dict:
    """Publishes the specified image and its metadata to the `analyze_image`
    SNS Topic to be processed by the detection Lambdas.

    An appropriate HandlerException is raised if any errors are encountered
    or the SNS publish is not successful.

    :param image_url: The URL of the image.
    :param post_id: The id of the post sharing the image.
    :param account_id: The account id that authored the post.
    :param source_device: The type of device that published the image.
    :param created_timestamp:  The timestamp.
    :param root_trace_id: The id of the root trace that is initiating this
        processing.
    :param log_context: The log context to use to emit log messages.
    :return: The response from SNS if the publish is successful.
    """
    payload = ImagePayload(
        image_url, post_id, account_id, source_device, created_timestamp, root_trace_id
    )
    return _publish_to_sns_topic(
        'analyze_image', 'SNS_ANALYZE_IMAGE_TOPIC_ARN', payload, log_context=log_context
    )


def publish_to_update_spam_score_sns_topic(
    image_payload: ImagePayload,
    scorer: str,
    score: float,
    scorer_trace_id,
    log_context: LogContext = None,
) -> dict:
    """Publishes the specified image and its metadata to the `update_spam_score`
    SNS Topic to be processed by UpdateSpamScore Lambda.

    An appropriate HandlerException is raised if any errors are encountered
    or the SNS publish is not successful.

    :param image_payload: The image payload that was scored
    :param scorer: The name of the scorer
    :param score: The score between 0 and 1.
    :param scorer_trace_id: The trace id that performed this scoring.
    :param log_context: The log context to use to emit log messages.
    :return: The response from SNS if the publish is successful.
    """
    payload = UpdateSpamScorePayload(image_payload, scorer, score, scorer_trace_id)
    return _publish_to_sns_topic(
        'update_spam_score',
        'SNS_UPDATE_SPAM_SCORE_TOPIC_ARN',
        payload,
        log_context=log_context,
    )


def _receive_from_sns_topic(event: dict) -> str:
    """Receives an event from an SNS topic and extracts the underlying message.

    An appropriate HandlerException is raised if there are any errors.

    :param event: The event that triggered the Lambda.
    :return: The underlying message.
    """
    try:
        return event['Records'][0]['Sns']['Message']
    except KeyError as e:
        raise SnsReceiveError(f"Missing field {e} when receiving sns event")


def receive_from_analyze_image_sns_topic(event: dict) -> ImagePayload:
    """Receives an event from the analyze_image SNS topic and extracts
    the underlying ImagePayload object.

    An appropriate HandlerException is raised if there are any errors.

    :param event: The event that triggered the Lambda.
    :return: The underlying ImagePayload.
    """
    return ImagePayload.from_json(_receive_from_sns_topic(event))


def receive_from_update_spam_score_sns_topic(event: dict) -> UpdateSpamScorePayload:
    """Receives an event from the update_spam_score SNS topic and extracts
    the underlying UpdateSpamScorePayload object.

    An appropriate HandlerException is raised if there are any errors.

    :param event: The event that triggered the Lambda.
    :return: The underlying UpdateSpamScorePayload.
    """
    return UpdateSpamScorePayload.from_json(_receive_from_sns_topic(event))


class DetectionHandler:
    """Base class for all handlers that calculate a spam score for an image.
    """

    def __init__(self, handler_name: str):
        """Creates an instance.

        :param handler_name: The name of the handler deriving this class.
        """
        self.__handler_name = handler_name
        self._log_context: Union[LogContext, None] = None

    def handle_request(self, event: dict, context) -> dict:
        """Handles a Lambda invocation.

        :param event: The event passed into the Lambda invocation.
        :param context: The context passed into the Lambda invocation.
        :return: The response to return for the Lambda invocation.
        """
        try:
            image_payload = receive_from_analyze_image_sns_topic(event)

            self._log_context = LogContext(
                self.__handler_name,
                context.function_version,
                root_trace=image_payload.root_trace_id,
                parent_trace=image_payload.root_trace_id,
                current_trace=context.aws_request_id,
            )
            self._log_context.log_start_message()

            score = self._score_image(image_payload)

            # TODO:  Maybe we should make this raise an exception?
            if score < 0 or score > 1:
                self._log_context.log(
                    f"Warning, invalid spam score computed. "
                    f"Should be between 0 and 1: {score}"
                )

            self._log_context.log(
                f"score_computed algorithm={self.__handler_name} "
                f"score={score} image={image_payload.image_url} "
                f"account_id={image_payload.account_id}"
            )

            publish_to_update_spam_score_sns_topic(
                image_payload,
                self.__handler_name,
                score,
                context.aws_request_id,
                log_context=self._log_context,
            )

            self._log_context.log_end_message(200, "Success")
            return {
                'statusCode': 200,
                'headers': {'Content-Type': 'text/plain'},
                'body': 'Hello, you have reached {}.'.format(self.__handler_name),
            }
        except HandlerError as e:
            print(f"[ERROR] {e}: ")
            traceback.print_stack()
            if self._log_context is not None:
                self._log_context.log_end_message(
                    e.status_code, f"Failed due to exception: {e}"
                )
            return e.create_response(for_sns_topic=True)

    # noinspection PyMethodMayBeStatic
    def _score_image(self, _image_payload: ImagePayload) -> float:
        """Derived classes must override this to define how they will calculate
        spam scores.

        :param _image_payload: The image to score.
        :return: The spam score from 0 to 1.
        """
        return 0


class S3Url(object):
    """
    Helper class that takes a S3 URL in format
    and has methods to retrieve the Bucket name, Key name, and entire URL
    :param url: A S3 URL such as "S3://bucket/path/file.jpeg"
    :type url: str
    """

    def __init__(self, url):
        try:
            self._parsed = urlparse(url, allow_fragments=False)

            self._bucket = self._parsed.netloc
            self._key = self._parsed.path.lstrip('/')
            self._url = self._parsed.geturl()
        except ValueError:
            print("exception while attempting to urlparse: {}".format(url))
            raise

    @property
    def bucket(self) -> str:
        return self._bucket

    @property
    def key(self) -> str:
        return self._key

    @property
    def url(self) -> str:
        return self._url
